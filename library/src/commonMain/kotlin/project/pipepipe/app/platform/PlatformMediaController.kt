package project.pipepipe.app.platform

import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.flow.StateFlow
import project.pipepipe.app.PlaybackMode
import project.pipepipe.app.SharedContext
import project.pipepipe.app.helper.FormatHelper
import project.pipepipe.shared.infoitem.StreamInfo
import kotlin.math.min

data class SubtitleCue(
    val text: String,
    val line: Float? = null,
    val position: Float? = null,
)

data class ResolutionInfo(
    val height: Int,
    val width: Int,
    val codec: String?,
    val frameRate: Float,
    val isSelected: Boolean,
    val isHDR: Boolean = false
) {
    val resolutionPixel: String get() = "${min(height, width)}p"

    val displayLabel: String
        get() {
            val codecName = FormatHelper.parseCodecName(codec)
            val baseLabel = FormatHelper.formatVideoLabel(codecName, resolutionPixel, frameRate)
            return if (isHDR) "$baseLabel HDR" else baseLabel
        }

    val codecPriority: Int get() = FormatHelper.getCodecPriority(codec)



}

data class SubtitleInfo(
    val language: String,
    val isSelected: Boolean,
    val isAutoGenerated: Boolean = false
)

data class AudioLanguageInfo(
    val language: String,
    val isDefault: Boolean,
    val isSelected: Boolean
)

interface PlatformMediaController {

    val scope: CoroutineScope

    val isPlaying: StateFlow<Boolean>

    val currentPosition: StateFlow<Long>

    fun getCurrentPositionRealtime(): Long

    val duration: StateFlow<Long>

    val playbackState: StateFlow<PlaybackState>

    val currentSubtitles: StateFlow<List<SubtitleCue>>

    val repeatMode: StateFlow<RepeatMode>

    val shuffleModeEnabled: StateFlow<Boolean>

    val playbackSpeed: StateFlow<Float>

    val playbackPitch: StateFlow<Float>

    val bufferedPosition: StateFlow<Long>

    val availableResolutions: StateFlow<List<ResolutionInfo>>

    val availableSubtitles: StateFlow<List<SubtitleInfo>>

    val availableAudioLanguages: StateFlow<List<AudioLanguageInfo>>

    val currentAudioLanguage: StateFlow<String>

    fun play()

    fun pause()

    fun stop()

    fun seekTo(positionMs: Long)

    fun seekToItem(index: Int, positionMs: Long? = null) {
        val item = SharedContext.queueManager.getCurrentQueue().getOrNull(index)
        if (item != null) {
            SharedContext.queueManager.setIndex(index)
            loadMediaQueueForItem(item, positionMs)
        }
    }

    fun seekToPrevious()

    fun seekToNext()


    fun loadMediaQueueForItem(item: PlatformMediaItem, startPositionMs: Long? = null, shouldKeepPosition: Boolean = false)


    fun loadMediaQueueForCurrentItem(startPositionMs: Long? = null, shouldKeepPosition: Boolean = false)

    fun setRepeatMode(mode: RepeatMode)

    fun setShuffleModeEnabled(enabled: Boolean)

    fun setPlaybackParameters(speed: Float, pitch: Float)

    val nativePlayer: Any

    fun prepare()

    fun release()

    fun setPlaybackMode(mode: PlaybackMode)

    fun playFromStreamInfo(streamInfo: StreamInfo)

    fun setStreamInfoAsOnlyMediaItem(streamInfo: StreamInfo)

    fun backgroundPlay(streamInfo: StreamInfo)

    fun enqueue(streamInfo: StreamInfo)

    fun playAll(items: List<StreamInfo>, startIndex: Int = 0, shuffle: Boolean = false)

    fun getAvailableResolutions(): List<ResolutionInfo>

    fun getAvailableSubtitles(): List<SubtitleInfo>

    fun selectResolution(resolution: ResolutionInfo, isManual: Boolean = true)

    fun selectSubtitle(subtitle: SubtitleInfo)

    fun applyDefaultResolution(defaultResolution: String)

    fun clearResolutionOverride()

    fun selectAudioLanguage(language: String)

    fun disableSubtitles()

    fun stopService()

    fun addPlaybackEventCallback(callback: PlaybackEventCallback)

    fun removePlaybackEventCallback(callback: PlaybackEventCallback)
}

interface PlaybackEventCallback {
    fun onMediaItemTransition() {}

    fun onSeek() {}

    fun onTracksChanged() {}
}

enum class PlaybackState {
    IDLE,
    BUFFERING,
    READY,
    ENDED
}

enum class RepeatMode {
    OFF,
    ONE,
    ALL
}
