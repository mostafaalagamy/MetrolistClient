package project.pipepipe.app.platform

import kotlinx.coroutines.flow.StateFlow
import project.pipepipe.app.PlaybackMode
import project.pipepipe.app.helper.FormatHelper
import project.pipepipe.shared.infoitem.StreamInfo
import kotlin.math.min

/**
 * Platform-independent subtitle cue.
 * Represents a single subtitle text with optional positioning.
 */
data class SubtitleCue(
    /** The subtitle text content */
    val text: String,
    /** Vertical position as a fraction (0.0 = top, 1.0 = bottom), null for default positioning */
    val line: Float? = null,
    /** Horizontal position as a fraction (0.0 = left, 1.0 = right), null for default (center) */
    val position: Float? = null,
)

/**
 * Platform-independent video resolution option.
 * Represents a single video track with resolution, codec, and metadata.
 */
data class ResolutionInfo(
    /** Video height in pixels */
    val height: Int,
    /** Video width in pixels */
    val width: Int,
    /** Codec string (e.g., "avc1.640028") */
    val codec: String?,
    /** Frame rate in frames per second */
    val frameRate: Float,
    /** Whether this track is currently selected */
    val isSelected: Boolean,
    /** Whether this track is HDR (High Dynamic Range) */
    val isHDR: Boolean = false
) {
    /**
     * Resolution in pixel format (e.g., "1080p")
     * Uses the smaller dimension for landscape videos, or height for portrait
     */
    val resolutionPixel: String get() = "${min(height, width)}p"

    /**
     * Display label for UI
     * Format: "Codec resolution" or "Codec resolution frameRate" (if > 30fps)
     * Appends "HDR" suffix for HDR tracks
     */
    val displayLabel: String
        get() {
            val codecName = FormatHelper.parseCodecName(codec)
            val baseLabel = FormatHelper.formatVideoLabel(codecName, resolutionPixel, frameRate)
            return if (isHDR) "$baseLabel HDR" else baseLabel
        }

    /**
     * Codec priority for sorting
     * Higher priority means better codec quality
     */
    val codecPriority: Int get() = FormatHelper.getCodecPriority(codec)



}

/**
 * Platform-independent subtitle option.
 * Represents a single subtitle track.
 */
data class SubtitleInfo(
    /** Language code (e.g., "en", "zh-CN") */
    val language: String,
    /** Whether this track is currently selected */
    val isSelected: Boolean,
    /** Whether this subtitle is auto-generated */
    val isAutoGenerated: Boolean = false
)

/**
 * Platform-independent audio language option.
 * Represents a single audio track language.
 */
data class AudioLanguageInfo(
    /** Language code (e.g., "en", "zh-CN") */
    val language: String,
    /** Whether this is the default/main audio track */
    val isDefault: Boolean,
    /** Whether this track is currently selected */
    val isSelected: Boolean
)

/**
 * Platform-independent media playback controller interface.
 * Abstracts Media3 MediaController on Android and AVQueuePlayer on iOS.
 */
interface PlatformMediaController {
    // ===== Playback State =====

    /** Whether media is currently playing */
    val isPlaying: StateFlow<Boolean>

    /** Current playback position in milliseconds */
    val currentPosition: StateFlow<Long>

    /** Duration of current item in milliseconds */
    val duration: StateFlow<Long>

    /** Current playback state */
    val playbackState: StateFlow<PlaybackState>

    /** Current subtitle cues */
    val currentSubtitles: StateFlow<List<SubtitleCue>>

    // ===== Queue State =====

    /** Current play queue */
    val playQueue: StateFlow<List<PlatformMediaItem>>

    /** Number of items in the queue */
    val mediaItemCount: StateFlow<Int>

    /** Index of currently playing item in the queue */
    val currentItemIndex: StateFlow<Int>

    /** Currently playing media item */
    val currentMediaItem: StateFlow<PlatformMediaItem?>

    // ===== Playback Settings =====

    /** Current repeat mode */
    val repeatMode: StateFlow<RepeatMode>

    /** Whether shuffle mode is enabled */
    val shuffleModeEnabled: StateFlow<Boolean>

    /** Current playback speed */
    val playbackSpeed: StateFlow<Float>

    /** Current playback pitch */
    val playbackPitch: StateFlow<Float>

    /** Buffered position in milliseconds */
    val bufferedPosition: StateFlow<Long>

    /** Available video resolutions */
    val availableResolutions: StateFlow<List<ResolutionInfo>>

    /** Available subtitle tracks */
    val availableSubtitles: StateFlow<List<SubtitleInfo>>

    /** Available audio languages */
    val availableAudioLanguages: StateFlow<List<AudioLanguageInfo>>

    /** Current audio language */
    val currentAudioLanguage: StateFlow<String>

    // ===== Playback Controls =====

    /** Start or resume playback */
    fun play()

    /** Pause playback */
    fun pause()

    /** Stop playback and release resources */
    fun stop()

    /** Seek to position in milliseconds */
    fun seekTo(positionMs: Long)

    /** Seek to specific item in queue */
    fun seekToItem(index: Int, positionMs: Long = 0)

    /** Seek to previous item */
    fun seekToPrevious()

    /** Seek to next item */
    fun seekToNext()

    // ===== Queue Operations =====

    /** Set a single media item and optionally start playback */
    fun setMediaItem(item: PlatformMediaItem, startPositionMs: Long = 0)

    /** Set queue with multiple items */
    fun setQueue(items: List<PlatformMediaItem>, startIndex: Int = 0, startPositionMs: Long = 0)

    /** Add item to end of queue */
    fun addMediaItem(item: PlatformMediaItem)

    /** Insert item at specific position */
    fun insertItem(index: Int, item: PlatformMediaItem)

    /** Remove item at specific position */
    fun removeItem(index: Int)

    /** Move item from one position to another */
    fun moveItem(from: Int, to: Int)

    /** Clear the queue */
    fun clearQueue()

    // ===== Settings Controls =====

    /** Set repeat mode */
    fun setRepeatMode(mode: RepeatMode)

    /** Enable or disable shuffle mode */
    fun setShuffleModeEnabled(enabled: Boolean)

    /** Set playback speed and pitch */
    fun setPlaybackParameters(speed: Float, pitch: Float)

    // ===== Lifecycle =====

    /** Native player instance for platform-specific rendering (e.g., Media3 Player on Android) */
    val nativePlayer: Any

    /** Prepare the player for playback */
    fun prepare()

    /** Release player resources */
    fun release()

    // ===== Business Operations =====

    /** Set playback mode (video+audio or audio only) */
    fun setPlaybackMode(mode: PlaybackMode)

    /**
     * Start playback from StreamInfo.
     * Handles media item creation, progress restoration, and history recording.
     */
    fun playFromStreamInfo(streamInfo: StreamInfo)

    /**
     * Set StreamInfo as the only media item in queue.
     * Used when showing as bottom player (AUDIO_ONLY mode).
     * Handles playback mode switch and progress restoration.
     */
    fun setStreamInfoAsOnlyMediaItem(streamInfo: StreamInfo)

    // ===== Track Selection =====

    /**
     * Get available video resolution options.
     * Returns a list of all video tracks with their resolution, codec, and selection state.
     */
    fun getAvailableResolutions(): List<ResolutionInfo>

    /**
     * Get available subtitle options.
     * Returns a list of all subtitle tracks with their language and selection state.
     */
    fun getAvailableSubtitles(): List<SubtitleInfo>

    /**
     * Select a specific video resolution.
     * @param resolution The resolution option to select
     */
    fun selectResolution(resolution: ResolutionInfo)

    /**
     * Select a specific subtitle track.
     * @param subtitle The subtitle option to select
     */
    fun selectSubtitle(subtitle: SubtitleInfo)

    /**
     * Apply default resolution setting.
     * Automatically selects the appropriate resolution based on user preference.
     * Supported values: "best", "lowest", "1080p", "720p", "480p", "360p"
     * @param defaultResolution The default resolution setting
     */
    fun applyDefaultResolution(defaultResolution: String)

    /**
     * Clear video resolution override and use auto selection.
     */
    fun clearResolutionOverride()

    /**
     * Select audio track by language.
     * @param language The language code to select
     */
    fun selectAudioLanguage(language: String)

    /**
     * Disable subtitle display.
     */
    fun disableSubtitles()

    /**
     * Stop the playback service completely.
     */
    fun stopService()

    // ===== Event Callbacks =====

    /**
     * Register a callback for playback events.
     * @param callback The callback to register
     */
    fun addPlaybackEventCallback(callback: PlaybackEventCallback)

    /**
     * Unregister a playback event callback.
     * @param callback The callback to unregister
     */
    fun removePlaybackEventCallback(callback: PlaybackEventCallback)
}

/**
 * Callback interface for playback events that require special handling.
 */
interface PlaybackEventCallback {
    /** Called when media item transitions */
    fun onMediaItemTransition() {}

    /** Called when seek operation occurs */
    fun onSeek() {}

    /** Called when auto-transition between items occurs (e.g., playlist advancement) */
    fun onAutoTransition() {}

    /** Called when tracks change (resolution, audio, subtitle availability) */
    fun onTracksChanged() {}
}

/**
 * Playback state enum, platform-independent.
 */
enum class PlaybackState {
    /** Player is idle, not ready to play */
    IDLE,
    /** Player is buffering */
    BUFFERING,
    /** Player is ready to play */
    READY,
    /** Playback has ended */
    ENDED
}

/**
 * Repeat mode enum, platform-independent.
 */
enum class RepeatMode {
    /** No repeat */
    OFF,
    /** Repeat current item */
    ONE,
    /** Repeat entire queue */
    ALL
}
