package project.pipepipe.app.platform

import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.runBlocking
import project.pipepipe.app.PlaybackMode
import project.pipepipe.app.SharedContext
import project.pipepipe.app.database.DatabaseOperations
import project.pipepipe.app.helper.FormatHelper
import project.pipepipe.shared.infoitem.StreamInfo
import kotlin.math.min

data class SubtitleCue(
    val text: String,
    val line: Float? = null,
    val position: Float? = null,
)

data class ResolutionInfo(
    val height: Int,
    val width: Int,
    val codec: String?,
    val frameRate: Float,
    val isSelected: Boolean,
    val isHDR: Boolean = false
) {
    val resolutionPixel: String get() = "${min(height, width)}p"

    val displayLabel: String
        get() {
            val codecName = FormatHelper.parseCodecName(codec)
            val baseLabel = FormatHelper.formatVideoLabel(codecName, resolutionPixel, frameRate)
            return if (isHDR) "$baseLabel HDR" else baseLabel
        }

    val codecPriority: Int get() = FormatHelper.getCodecPriority(codec)



}

data class SubtitleInfo(
    val language: String,
    val isSelected: Boolean,
    val isAutoGenerated: Boolean = false
)

data class AudioLanguageInfo(
    val language: String,
    val isDefault: Boolean,
    val isSelected: Boolean
)

interface PlatformMediaController {

    val scope: CoroutineScope

    val isPlaying: StateFlow<Boolean>

    val currentPosition: StateFlow<Long>

    fun getCurrentPositionRealtime(): Long

    val duration: StateFlow<Long>

    val playbackState: StateFlow<PlaybackState>

    val currentSubtitles: StateFlow<List<SubtitleCue>>
    val currentMediaItem: StateFlow<PlatformMediaItem?>
    val currentItemIndex: StateFlow<Int>


    fun isLastMediaItem(): Boolean = currentMediaItem.value?.uuid == SharedContext.queueManager.getCurrentQueue().last().uuid
    fun isFirstMediaItem(): Boolean = currentMediaItem.value?.uuid == SharedContext.queueManager.getCurrentQueue().first().uuid

    val repeatMode: StateFlow<RepeatMode>

    val shuffleModeEnabled: StateFlow<Boolean>

    val playbackSpeed: StateFlow<Float>

    val playbackPitch: StateFlow<Float>

    val bufferedPosition: StateFlow<Long>

    val availableResolutions: StateFlow<List<ResolutionInfo>>

    val availableSubtitles: StateFlow<List<SubtitleInfo>>

    val availableAudioLanguages: StateFlow<List<AudioLanguageInfo>>

    val currentAudioLanguage: StateFlow<String>

    fun play()

    fun pause()

    fun stop()

    fun seekTo(positionMs: Long)

    fun seekToItem(index: Int, positionMs: Long = 0)

    fun seekToPrevious()

    fun seekToNext()

    fun setQueue(items: List<PlatformMediaItem>, startIndex: Int)

    fun setRepeatMode(mode: RepeatMode)

    fun setShuffleModeEnabled(enabled: Boolean)

    fun setPlaybackParameters(speed: Float, pitch: Float)

    val nativePlayer: Any

    fun prepare()

    fun release()

    fun setPlaybackMode(mode: PlaybackMode)

    fun playFromStreamInfo(streamInfo: StreamInfo)

    fun setStreamInfoAsOnlyMediaItem(streamInfo: StreamInfo)

    fun backgroundPlay(streamInfo: StreamInfo)

    fun enqueue(streamInfo: StreamInfo)

    fun playAll(items: List<StreamInfo>, startIndex: Int = 0, shuffle: Boolean = false)

    fun getAvailableResolutions(): List<ResolutionInfo>

    fun getAvailableSubtitles(): List<SubtitleInfo>

    fun selectResolution(resolution: ResolutionInfo, isManual: Boolean = true)

    fun selectSubtitle(subtitle: SubtitleInfo)

    fun applyDefaultResolution(defaultResolution: String)

    fun clearResolutionOverride()

    fun selectAudioLanguage(language: String)

    fun disableSubtitles()

    fun stopService()

    fun syncQueueShuffle()

    fun syncQueueClear()

    fun syncQueueRemove(index: Int)

    fun syncQueueAppend(item: PlatformMediaItem)

    fun syncQueueMove(from: Int, to: Int)
}

enum class PlaybackState {
    IDLE,
    BUFFERING,
    READY,
    ENDED
}

enum class RepeatMode {
    OFF,
    ONE,
    ALL
}

fun getPlaybackStartPosition(item: PlatformMediaItem): Long = runBlocking {
    if (SharedContext.playbackMode.value == PlaybackMode.AUDIO_ONLY) {
        return@runBlocking 0
    }
    val progress = DatabaseOperations.getStreamProgress(item.mediaId)
    if (progress != null && item.durationMs != null &&
        item.durationMs - progress > 5000
    ) {
        progress
    } else {
        0L
    }
}